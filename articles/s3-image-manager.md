---
title: "Uploading and Managing Images with S3 and MinIO in Next.js"
publishedAt: "2026-01-11"
summary: "A beginner-friendly guide to building a secure file upload system using Next.js, presigned URLs, and S3-compatible storage like MinIO."
tags: ["nextjs", "s3", "minio", "aws", "typescript"]
image: "https://i.ibb.co/zWkPGwFp/s3.webp"
---

Building a file upload system in modern web apps can be tricky, especially if you want **direct uploads from the browser**, **progress tracking**, and **file management**. In this guide, I’ll walk you through a **Next.js** example using **AWS S3** (or a self-hosted **MinIO**) with **presigned URLs**, drag-and-drop uploads, a gallery view, and delete functionality.

---

## 1. Architecture Overview

Before diving into code, it is essential to understand the "Handshake." Instead of sending heavy image data to your Next.js server (which can be slow and expensive), we ask the server for a temporary "permission slip" (the Presigned URL) so the browser can upload directly to storage.

![Architecture](/images/blogs/s3-image-manager/architecture.png)

### Key Concepts

- **S3 / MinIO**: Storage backend for your files. MinIO is a self-hosted S3-compatible solution that works locally or on your server.
- **Presigned URLs**: URLs generated by the server that allow the browser to upload directly to S3 **without exposing credentials**. They expire after a short time (e.g., 6 minutes).

---

## 2. Environment Setup

Create a `.env` file with the following variables. These allow your app to connect to either AWS S3 or a self-hosted MinIO instance.

```env
S3_ENDPOINT=           # e.g., http://127.0.0.1:9000 for MinIO
S3_ACCESS_KEY_ID=
S3_SECRET_ACCESS_KEY=
S3_REGION=
S3_BUCKET_NAME=

```

### Running MinIO Locally with Docker

If you don't want to set up an AWS account yet, you can run MinIO locally using Docker. Run the following command in your terminal to start a container:

```bash
docker run \
  -d \
  -p 9000:9000 \
  -p 9001:9001 \
  --name minio \
  -e "MINIO_ROOT_USER=S3_ACCESS_KEY_ID" \
  -e "MINIO_ROOT_PASSWORD=S3_SECRET_ACCESS_KEY" \
  -v ./data:/data \
  --restart=always \
  quay.io/minio/minio server /data --console-address ":9001"

```

> ⚡ **Tip:** After running this, you can access the MinIO dashboard at `http://localhost:9001` to create your bucket and view your uploaded files in real-time.

![MinIO](/images/blogs/s3-image-manager/minio.png)

---

## 3. Setting Up the S3 Client

We use the `@aws-sdk/client-s3` package to create a reusable client. The `forcePathStyle` setting is crucial—it's what makes the code compatible with MinIO's local URL structure.

```ts
import { S3Client } from "@aws-sdk/client-s3";

const options = {
  region: process.env.S3_REGION || "auto",
  endpoint: process.env.S3_ENDPOINT,
  forcePathStyle: true, // Required for MinIO compatibility
  credentials: {
    accessKeyId: process.env.S3_ACCESS_KEY_ID!,
    secretAccessKey: process.env.S3_SECRET_ACCESS_KEY!,
  },
};

export const S3 = new S3Client(options);
```

---

## 4. Uploading Files Using Presigned URLs

### The Server-Side "Handshake" (`/api/s3/upload`)

When a user selects a file, we don't immediately start the upload. Instead, the browser initiates a "handshake" with our Next.js API. At this stage, the browser only sends the **metadata**—the file name, size, and content type.

Our server uses this information to talk to S3 and generate a **Presigned URL**. Think of this as a temporary "VIP Pass" that tells the storage bucket: _"This specific user is allowed to upload this specific file, but only for the next few minutes."_

```ts
import { PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { S3 } from "@/lib/S3Client";
import { v4 as uuidv4 } from "uuid";

export async function POST(req: Request) {
  const { filename, contentType, size } = await req.json();

  // Create a unique key to prevent different users from overwriting files
  const key = `${uuidv4()}-${filename}`;

  const command = new PutObjectCommand({
    Bucket: process.env.S3_BUCKET_NAME!,
    Key: key,
    ContentType: contentType,
    ContentLength: size,
  });

  // Generate the temporary URL and return it to the browser
  const presignedUrl = await getSignedUrl(S3, command, { expiresIn: 360 });
  return new Response(JSON.stringify({ presignedUrl, key }));
}
```

### Direct Upload from the Browser (`ImageDropZone`)

Once the browser receives the "VIP Pass" (the Presigned URL), it’s time for the heavy lifting. Instead of funneling the file through your Next.js server, the browser uploads it **directly** to S3 or MinIO.

For this step, we use **XMLHttpRequest (XHR)** rather than the standard `fetch` API. While `fetch` is modern and clean, it doesn't natively support **upload progress tracking**. By using XHR, we can hook into the `progress` event to give users real-time feedback, making the app feel responsive and professional.

```tsx
async function uploadFile(file: File) {
  // 1. Get the "permission slip" (the Presigned URL) from our API
  const { presignedUrl, key } = await fetch("/api/s3/upload", {
    method: "POST",
    body: JSON.stringify({
      filename: file.name,
      contentType: file.type,
      size: file.size,
    }),
  }).then((res) => res.json());

  // 2. Use XHR to upload directly to S3 with progress tracking
  const xhr = new XMLHttpRequest();

  xhr.upload.onprogress = (event) => {
    if (event.lengthComputable) {
      const progress = (event.loaded / event.total) * 100;
      // Update your UI state (e.g., a progress bar) here
      console.log(`Upload progress: ${progress}%`);
    }
  };

  xhr.open("PUT", presignedUrl);
  xhr.setRequestHeader("Content-Type", file.type);
  xhr.send(file);
}
```

![Dropzone](/images/blogs/s3-image-manager/dropzone.png)

---

## 5. Listing and Managing the Gallery

### Displaying Private Files Securely (`ImageGallery`)

Once your files are safely stored in the cloud, the next challenge is displaying them. Since our bucket is set to **private** for security, you can't simply link to the file's raw URL—the browser would receive a "403 Forbidden" error.

To solve this, we generate **Presigned GET URLs**. Think of this as giving the browser a temporary "viewing key." Each image in your gallery gets its own unique, time-bound link that allows it to be rendered in an `<img>` tag without making the entire bucket public.

```ts
import { ListObjectsV2Command, GetObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { S3 } from "@/lib/S3Client";

export async function GET() {
  // 1. Fetch the list of objects from the bucket
  const listCommand = new ListObjectsV2Command({
    Bucket: process.env.S3_BUCKET_NAME!,
    MaxKeys: 12, // Fetch the latest 12 images
  });

  const response = await S3.send(listCommand);

  // 2. Map through the files and generate a temporary "viewing key" for each
  const files = await Promise.all(
    (response.Contents ?? []).map(async (file) => {
      const getCommand = new GetObjectCommand({
        Bucket: process.env.S3_BUCKET_NAME!,
        Key: file.Key!,
      });

      // The URL will expire in 5 minutes (300 seconds)
      const url = await getSignedUrl(S3, getCommand, { expiresIn: 300 });

      return {
        key: file.Key,
        url,
      };
    })
  );

  return new Response(JSON.stringify({ files }));
}
```

![Gallery](/images/blogs/s3-image-manager/gallery.png)

---

## 6. Key Takeaways

Building a file management system is about more than just moving bytes; it’s about balancing security with a great user experience. Here are the core lessons to keep in mind:

- **Prioritize Security**: Avoid uploading files directly to your own server. By using **Presigned URLs**, you keep your server lightweight and ensure your storage credentials never leave the backend.
- **Prevent File Overwrites**: Never trust original filenames alone. Using a **UUID** (Unique Universal Identifier) ensures that if two users upload `vacation.jpg`, they won't overwrite each other's data.
- **Invest in UX**: A "blind" upload can be frustrating for users. Utilizing **XHR progress bars** and success "toast" notifications makes your application feel fast, responsive, and professional.
- **Don't Forget CORS**: The most common "gotcha" for beginners is a Cross-Origin Resource Sharing (CORS) error. Ensure your S3 or MinIO bucket is explicitly configured to allow `PUT` and `GET` requests from your local development domain (e.g., `http://localhost:3000`).

---

**Source code:** [https://github.com/aymoun95/image-upload-manager](https://github.com/aymoun95/image-upload-manager)
